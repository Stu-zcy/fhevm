/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export interface FHEVMExecutorUpgradedExampleInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "HANDLE_VERSION"
      | "UPGRADE_INTERFACE_VERSION"
      | "_verifyAndReturnType"
      | "acceptOwnership"
      | "cast"
      | "fheAdd"
      | "fheBitAnd"
      | "fheBitOr"
      | "fheBitXor"
      | "fheDiv"
      | "fheEq"
      | "fheGe"
      | "fheGt"
      | "fheIfThenElse"
      | "fheLe"
      | "fheLt"
      | "fheMax"
      | "fheMin"
      | "fheMul"
      | "fheNe"
      | "fheNeg"
      | "fheNot"
      | "fheRand"
      | "fheRandBounded"
      | "fheRem"
      | "fheRotl"
      | "fheRotr"
      | "fheShl"
      | "fheShr"
      | "fheSub"
      | "getACLAddress"
      | "getHCULimitAddress"
      | "getInputVerifierAddress"
      | "getVersion"
      | "initializeFromEmptyProxy"
      | "owner"
      | "peekTypeAndHandle"
      | "pendingOwner"
      | "proxiableUUID"
      | "reinitializeV2"
      | "renounceOwnership"
      | "transferOwnership"
      | "trivialEncrypt"
      | "upgradeToAndCall"
      | "verifyCiphertext"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "Cast"
      | "FheAdd"
      | "FheBitAnd"
      | "FheBitOr"
      | "FheBitXor"
      | "FheDiv"
      | "FheEq"
      | "FheGe"
      | "FheGt"
      | "FheIfThenElse"
      | "FheLe"
      | "FheLt"
      | "FheMax"
      | "FheMin"
      | "FheMul"
      | "FheNe"
      | "FheNeg"
      | "FheNot"
      | "FheRand"
      | "FheRandBounded"
      | "FheRem"
      | "FheRotl"
      | "FheRotr"
      | "FheShl"
      | "FheShr"
      | "FheSub"
      | "Initialized"
      | "OwnershipTransferStarted"
      | "OwnershipTransferred"
      | "TrivialEncrypt"
      | "Upgraded"
      | "VerifyCiphertext"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "HANDLE_VERSION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "UPGRADE_INTERFACE_VERSION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_verifyAndReturnType",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "acceptOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cast",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "fheAdd",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheBitAnd",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheBitOr",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheBitXor",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheDiv",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheEq",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheGe",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheGt",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheIfThenElse",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheLe",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheLt",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheMax",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheMin",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheMul",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheNe",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "fheNeg", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "fheNot", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "fheRand",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRandBounded",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRem",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRotl",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRotr",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheShl",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheShr",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheSub",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getACLAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getHCULimitAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getInputVerifierAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getVersion",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializeFromEmptyProxy",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "peekTypeAndHandle",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "pendingOwner",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "proxiableUUID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "reinitializeV2",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "trivialEncrypt",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeToAndCall",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyCiphertext",
    values: [BytesLike, AddressLike, BytesLike, BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "HANDLE_VERSION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "UPGRADE_INTERFACE_VERSION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_verifyAndReturnType",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "acceptOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "cast", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheAdd", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheBitAnd", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheBitOr", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheBitXor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheDiv", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheEq", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheGe", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheGt", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fheIfThenElse",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fheLe", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheLt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheMax", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheMin", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheMul", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheNe", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheNeg", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheNot", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheRand", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fheRandBounded",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fheRem", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheRotl", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheRotr", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheShl", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheShr", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheSub", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getACLAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getHCULimitAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getInputVerifierAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getVersion", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "initializeFromEmptyProxy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "peekTypeAndHandle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "pendingOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proxiableUUID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reinitializeV2",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "trivialEncrypt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeToAndCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyCiphertext",
    data: BytesLike
  ): Result;
}

export namespace CastEvent {
  export type InputTuple = [
    caller: AddressLike,
    ct: BytesLike,
    toType: BigNumberish,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    ct: string,
    toType: bigint,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    ct: string;
    toType: bigint;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheAddEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheBitAndEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheBitOrEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheBitXorEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheDivEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheEqEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheGeEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheGtEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheIfThenElseEvent {
  export type InputTuple = [
    caller: AddressLike,
    control: BytesLike,
    ifTrue: BytesLike,
    ifFalse: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    control: string,
    ifTrue: string,
    ifFalse: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    control: string;
    ifTrue: string;
    ifFalse: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheLeEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheLtEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheMaxEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheMinEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheMulEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheNeEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheNegEvent {
  export type InputTuple = [
    caller: AddressLike,
    ct: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [caller: string, ct: string, result: string];
  export interface OutputObject {
    caller: string;
    ct: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheNotEvent {
  export type InputTuple = [
    caller: AddressLike,
    ct: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [caller: string, ct: string, result: string];
  export interface OutputObject {
    caller: string;
    ct: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheRandEvent {
  export type InputTuple = [
    caller: AddressLike,
    randType: BigNumberish,
    seed: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    randType: bigint,
    seed: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    randType: bigint;
    seed: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheRandBoundedEvent {
  export type InputTuple = [
    caller: AddressLike,
    upperBound: BigNumberish,
    randType: BigNumberish,
    seed: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    upperBound: bigint,
    randType: bigint,
    seed: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    upperBound: bigint;
    randType: bigint;
    seed: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheRemEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheRotlEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheRotrEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheShlEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheShrEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheSubEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace InitializedEvent {
  export type InputTuple = [version: BigNumberish];
  export type OutputTuple = [version: bigint];
  export interface OutputObject {
    version: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferStartedEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TrivialEncryptEvent {
  export type InputTuple = [
    caller: AddressLike,
    pt: BigNumberish,
    toType: BigNumberish,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    pt: bigint,
    toType: bigint,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    pt: bigint;
    toType: bigint;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UpgradedEvent {
  export type InputTuple = [implementation: AddressLike];
  export type OutputTuple = [implementation: string];
  export interface OutputObject {
    implementation: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace VerifyCiphertextEvent {
  export type InputTuple = [
    caller: AddressLike,
    inputHandle: BytesLike,
    userAddress: AddressLike,
    inputProof: BytesLike,
    inputType: BigNumberish,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    inputHandle: string,
    userAddress: string,
    inputProof: string,
    inputType: bigint,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    inputHandle: string;
    userAddress: string;
    inputProof: string;
    inputType: bigint;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface FHEVMExecutorUpgradedExample extends BaseContract {
  connect(runner?: ContractRunner | null): FHEVMExecutorUpgradedExample;
  waitForDeployment(): Promise<this>;

  interface: FHEVMExecutorUpgradedExampleInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  HANDLE_VERSION: TypedContractMethod<[], [bigint], "view">;

  UPGRADE_INTERFACE_VERSION: TypedContractMethod<[], [string], "view">;

  _verifyAndReturnType: TypedContractMethod<
    [handle: BytesLike, supportedTypes: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  acceptOwnership: TypedContractMethod<[], [void], "nonpayable">;

  cast: TypedContractMethod<
    [ct: BytesLike, toType: BigNumberish],
    [string],
    "nonpayable"
  >;

  fheAdd: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheBitAnd: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheBitOr: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheBitXor: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheDiv: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheEq: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheGe: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheGt: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheIfThenElse: TypedContractMethod<
    [control: BytesLike, ifTrue: BytesLike, ifFalse: BytesLike],
    [string],
    "nonpayable"
  >;

  fheLe: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheLt: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheMax: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheMin: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheMul: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheNe: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheNeg: TypedContractMethod<[ct: BytesLike], [string], "nonpayable">;

  fheNot: TypedContractMethod<[ct: BytesLike], [string], "nonpayable">;

  fheRand: TypedContractMethod<
    [randType: BigNumberish],
    [string],
    "nonpayable"
  >;

  fheRandBounded: TypedContractMethod<
    [upperBound: BigNumberish, randType: BigNumberish],
    [string],
    "nonpayable"
  >;

  fheRem: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheRotl: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheRotr: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheShl: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheShr: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  fheSub: TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;

  getACLAddress: TypedContractMethod<[], [string], "view">;

  getHCULimitAddress: TypedContractMethod<[], [string], "view">;

  getInputVerifierAddress: TypedContractMethod<[], [string], "view">;

  getVersion: TypedContractMethod<[], [string], "view">;

  initializeFromEmptyProxy: TypedContractMethod<[], [void], "nonpayable">;

  owner: TypedContractMethod<[], [string], "view">;

  peekTypeAndHandle: TypedContractMethod<
    [handle: BytesLike],
    [
      [string, bigint, bigint] & {
        outHandle: string;
        rawType: bigint;
        typeCt: bigint;
      }
    ],
    "view"
  >;

  pendingOwner: TypedContractMethod<[], [string], "view">;

  proxiableUUID: TypedContractMethod<[], [string], "view">;

  reinitializeV2: TypedContractMethod<[], [void], "nonpayable">;

  renounceOwnership: TypedContractMethod<[], [void], "nonpayable">;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  trivialEncrypt: TypedContractMethod<
    [pt: BigNumberish, toType: BigNumberish],
    [string],
    "nonpayable"
  >;

  upgradeToAndCall: TypedContractMethod<
    [newImplementation: AddressLike, data: BytesLike],
    [void],
    "payable"
  >;

  verifyCiphertext: TypedContractMethod<
    [
      inputHandle: BytesLike,
      userAddress: AddressLike,
      inputProof: BytesLike,
      inputType: BigNumberish
    ],
    [string],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "HANDLE_VERSION"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "UPGRADE_INTERFACE_VERSION"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "_verifyAndReturnType"
  ): TypedContractMethod<
    [handle: BytesLike, supportedTypes: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "acceptOwnership"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "cast"
  ): TypedContractMethod<
    [ct: BytesLike, toType: BigNumberish],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheAdd"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheBitAnd"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheBitOr"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheBitXor"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheDiv"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheEq"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheGe"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheGt"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheIfThenElse"
  ): TypedContractMethod<
    [control: BytesLike, ifTrue: BytesLike, ifFalse: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheLe"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheLt"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheMax"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheMin"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheMul"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheNe"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheNeg"
  ): TypedContractMethod<[ct: BytesLike], [string], "nonpayable">;
  getFunction(
    nameOrSignature: "fheNot"
  ): TypedContractMethod<[ct: BytesLike], [string], "nonpayable">;
  getFunction(
    nameOrSignature: "fheRand"
  ): TypedContractMethod<[randType: BigNumberish], [string], "nonpayable">;
  getFunction(
    nameOrSignature: "fheRandBounded"
  ): TypedContractMethod<
    [upperBound: BigNumberish, randType: BigNumberish],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheRem"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheRotl"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheRotr"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheShl"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheShr"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheSub"
  ): TypedContractMethod<
    [lhs: BytesLike, rhs: BytesLike, scalarByte: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getACLAddress"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getHCULimitAddress"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getInputVerifierAddress"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getVersion"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "initializeFromEmptyProxy"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "peekTypeAndHandle"
  ): TypedContractMethod<
    [handle: BytesLike],
    [
      [string, bigint, bigint] & {
        outHandle: string;
        rawType: bigint;
        typeCt: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "pendingOwner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "proxiableUUID"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "reinitializeV2"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "renounceOwnership"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "trivialEncrypt"
  ): TypedContractMethod<
    [pt: BigNumberish, toType: BigNumberish],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "upgradeToAndCall"
  ): TypedContractMethod<
    [newImplementation: AddressLike, data: BytesLike],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "verifyCiphertext"
  ): TypedContractMethod<
    [
      inputHandle: BytesLike,
      userAddress: AddressLike,
      inputProof: BytesLike,
      inputType: BigNumberish
    ],
    [string],
    "nonpayable"
  >;

  getEvent(
    key: "Cast"
  ): TypedContractEvent<
    CastEvent.InputTuple,
    CastEvent.OutputTuple,
    CastEvent.OutputObject
  >;
  getEvent(
    key: "FheAdd"
  ): TypedContractEvent<
    FheAddEvent.InputTuple,
    FheAddEvent.OutputTuple,
    FheAddEvent.OutputObject
  >;
  getEvent(
    key: "FheBitAnd"
  ): TypedContractEvent<
    FheBitAndEvent.InputTuple,
    FheBitAndEvent.OutputTuple,
    FheBitAndEvent.OutputObject
  >;
  getEvent(
    key: "FheBitOr"
  ): TypedContractEvent<
    FheBitOrEvent.InputTuple,
    FheBitOrEvent.OutputTuple,
    FheBitOrEvent.OutputObject
  >;
  getEvent(
    key: "FheBitXor"
  ): TypedContractEvent<
    FheBitXorEvent.InputTuple,
    FheBitXorEvent.OutputTuple,
    FheBitXorEvent.OutputObject
  >;
  getEvent(
    key: "FheDiv"
  ): TypedContractEvent<
    FheDivEvent.InputTuple,
    FheDivEvent.OutputTuple,
    FheDivEvent.OutputObject
  >;
  getEvent(
    key: "FheEq"
  ): TypedContractEvent<
    FheEqEvent.InputTuple,
    FheEqEvent.OutputTuple,
    FheEqEvent.OutputObject
  >;
  getEvent(
    key: "FheGe"
  ): TypedContractEvent<
    FheGeEvent.InputTuple,
    FheGeEvent.OutputTuple,
    FheGeEvent.OutputObject
  >;
  getEvent(
    key: "FheGt"
  ): TypedContractEvent<
    FheGtEvent.InputTuple,
    FheGtEvent.OutputTuple,
    FheGtEvent.OutputObject
  >;
  getEvent(
    key: "FheIfThenElse"
  ): TypedContractEvent<
    FheIfThenElseEvent.InputTuple,
    FheIfThenElseEvent.OutputTuple,
    FheIfThenElseEvent.OutputObject
  >;
  getEvent(
    key: "FheLe"
  ): TypedContractEvent<
    FheLeEvent.InputTuple,
    FheLeEvent.OutputTuple,
    FheLeEvent.OutputObject
  >;
  getEvent(
    key: "FheLt"
  ): TypedContractEvent<
    FheLtEvent.InputTuple,
    FheLtEvent.OutputTuple,
    FheLtEvent.OutputObject
  >;
  getEvent(
    key: "FheMax"
  ): TypedContractEvent<
    FheMaxEvent.InputTuple,
    FheMaxEvent.OutputTuple,
    FheMaxEvent.OutputObject
  >;
  getEvent(
    key: "FheMin"
  ): TypedContractEvent<
    FheMinEvent.InputTuple,
    FheMinEvent.OutputTuple,
    FheMinEvent.OutputObject
  >;
  getEvent(
    key: "FheMul"
  ): TypedContractEvent<
    FheMulEvent.InputTuple,
    FheMulEvent.OutputTuple,
    FheMulEvent.OutputObject
  >;
  getEvent(
    key: "FheNe"
  ): TypedContractEvent<
    FheNeEvent.InputTuple,
    FheNeEvent.OutputTuple,
    FheNeEvent.OutputObject
  >;
  getEvent(
    key: "FheNeg"
  ): TypedContractEvent<
    FheNegEvent.InputTuple,
    FheNegEvent.OutputTuple,
    FheNegEvent.OutputObject
  >;
  getEvent(
    key: "FheNot"
  ): TypedContractEvent<
    FheNotEvent.InputTuple,
    FheNotEvent.OutputTuple,
    FheNotEvent.OutputObject
  >;
  getEvent(
    key: "FheRand"
  ): TypedContractEvent<
    FheRandEvent.InputTuple,
    FheRandEvent.OutputTuple,
    FheRandEvent.OutputObject
  >;
  getEvent(
    key: "FheRandBounded"
  ): TypedContractEvent<
    FheRandBoundedEvent.InputTuple,
    FheRandBoundedEvent.OutputTuple,
    FheRandBoundedEvent.OutputObject
  >;
  getEvent(
    key: "FheRem"
  ): TypedContractEvent<
    FheRemEvent.InputTuple,
    FheRemEvent.OutputTuple,
    FheRemEvent.OutputObject
  >;
  getEvent(
    key: "FheRotl"
  ): TypedContractEvent<
    FheRotlEvent.InputTuple,
    FheRotlEvent.OutputTuple,
    FheRotlEvent.OutputObject
  >;
  getEvent(
    key: "FheRotr"
  ): TypedContractEvent<
    FheRotrEvent.InputTuple,
    FheRotrEvent.OutputTuple,
    FheRotrEvent.OutputObject
  >;
  getEvent(
    key: "FheShl"
  ): TypedContractEvent<
    FheShlEvent.InputTuple,
    FheShlEvent.OutputTuple,
    FheShlEvent.OutputObject
  >;
  getEvent(
    key: "FheShr"
  ): TypedContractEvent<
    FheShrEvent.InputTuple,
    FheShrEvent.OutputTuple,
    FheShrEvent.OutputObject
  >;
  getEvent(
    key: "FheSub"
  ): TypedContractEvent<
    FheSubEvent.InputTuple,
    FheSubEvent.OutputTuple,
    FheSubEvent.OutputObject
  >;
  getEvent(
    key: "Initialized"
  ): TypedContractEvent<
    InitializedEvent.InputTuple,
    InitializedEvent.OutputTuple,
    InitializedEvent.OutputObject
  >;
  getEvent(
    key: "OwnershipTransferStarted"
  ): TypedContractEvent<
    OwnershipTransferStartedEvent.InputTuple,
    OwnershipTransferStartedEvent.OutputTuple,
    OwnershipTransferStartedEvent.OutputObject
  >;
  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;
  getEvent(
    key: "TrivialEncrypt"
  ): TypedContractEvent<
    TrivialEncryptEvent.InputTuple,
    TrivialEncryptEvent.OutputTuple,
    TrivialEncryptEvent.OutputObject
  >;
  getEvent(
    key: "Upgraded"
  ): TypedContractEvent<
    UpgradedEvent.InputTuple,
    UpgradedEvent.OutputTuple,
    UpgradedEvent.OutputObject
  >;
  getEvent(
    key: "VerifyCiphertext"
  ): TypedContractEvent<
    VerifyCiphertextEvent.InputTuple,
    VerifyCiphertextEvent.OutputTuple,
    VerifyCiphertextEvent.OutputObject
  >;

  filters: {
    "Cast(address,bytes32,uint8,bytes32)": TypedContractEvent<
      CastEvent.InputTuple,
      CastEvent.OutputTuple,
      CastEvent.OutputObject
    >;
    Cast: TypedContractEvent<
      CastEvent.InputTuple,
      CastEvent.OutputTuple,
      CastEvent.OutputObject
    >;

    "FheAdd(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheAddEvent.InputTuple,
      FheAddEvent.OutputTuple,
      FheAddEvent.OutputObject
    >;
    FheAdd: TypedContractEvent<
      FheAddEvent.InputTuple,
      FheAddEvent.OutputTuple,
      FheAddEvent.OutputObject
    >;

    "FheBitAnd(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheBitAndEvent.InputTuple,
      FheBitAndEvent.OutputTuple,
      FheBitAndEvent.OutputObject
    >;
    FheBitAnd: TypedContractEvent<
      FheBitAndEvent.InputTuple,
      FheBitAndEvent.OutputTuple,
      FheBitAndEvent.OutputObject
    >;

    "FheBitOr(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheBitOrEvent.InputTuple,
      FheBitOrEvent.OutputTuple,
      FheBitOrEvent.OutputObject
    >;
    FheBitOr: TypedContractEvent<
      FheBitOrEvent.InputTuple,
      FheBitOrEvent.OutputTuple,
      FheBitOrEvent.OutputObject
    >;

    "FheBitXor(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheBitXorEvent.InputTuple,
      FheBitXorEvent.OutputTuple,
      FheBitXorEvent.OutputObject
    >;
    FheBitXor: TypedContractEvent<
      FheBitXorEvent.InputTuple,
      FheBitXorEvent.OutputTuple,
      FheBitXorEvent.OutputObject
    >;

    "FheDiv(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheDivEvent.InputTuple,
      FheDivEvent.OutputTuple,
      FheDivEvent.OutputObject
    >;
    FheDiv: TypedContractEvent<
      FheDivEvent.InputTuple,
      FheDivEvent.OutputTuple,
      FheDivEvent.OutputObject
    >;

    "FheEq(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheEqEvent.InputTuple,
      FheEqEvent.OutputTuple,
      FheEqEvent.OutputObject
    >;
    FheEq: TypedContractEvent<
      FheEqEvent.InputTuple,
      FheEqEvent.OutputTuple,
      FheEqEvent.OutputObject
    >;

    "FheGe(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheGeEvent.InputTuple,
      FheGeEvent.OutputTuple,
      FheGeEvent.OutputObject
    >;
    FheGe: TypedContractEvent<
      FheGeEvent.InputTuple,
      FheGeEvent.OutputTuple,
      FheGeEvent.OutputObject
    >;

    "FheGt(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheGtEvent.InputTuple,
      FheGtEvent.OutputTuple,
      FheGtEvent.OutputObject
    >;
    FheGt: TypedContractEvent<
      FheGtEvent.InputTuple,
      FheGtEvent.OutputTuple,
      FheGtEvent.OutputObject
    >;

    "FheIfThenElse(address,bytes32,bytes32,bytes32,bytes32)": TypedContractEvent<
      FheIfThenElseEvent.InputTuple,
      FheIfThenElseEvent.OutputTuple,
      FheIfThenElseEvent.OutputObject
    >;
    FheIfThenElse: TypedContractEvent<
      FheIfThenElseEvent.InputTuple,
      FheIfThenElseEvent.OutputTuple,
      FheIfThenElseEvent.OutputObject
    >;

    "FheLe(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheLeEvent.InputTuple,
      FheLeEvent.OutputTuple,
      FheLeEvent.OutputObject
    >;
    FheLe: TypedContractEvent<
      FheLeEvent.InputTuple,
      FheLeEvent.OutputTuple,
      FheLeEvent.OutputObject
    >;

    "FheLt(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheLtEvent.InputTuple,
      FheLtEvent.OutputTuple,
      FheLtEvent.OutputObject
    >;
    FheLt: TypedContractEvent<
      FheLtEvent.InputTuple,
      FheLtEvent.OutputTuple,
      FheLtEvent.OutputObject
    >;

    "FheMax(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheMaxEvent.InputTuple,
      FheMaxEvent.OutputTuple,
      FheMaxEvent.OutputObject
    >;
    FheMax: TypedContractEvent<
      FheMaxEvent.InputTuple,
      FheMaxEvent.OutputTuple,
      FheMaxEvent.OutputObject
    >;

    "FheMin(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheMinEvent.InputTuple,
      FheMinEvent.OutputTuple,
      FheMinEvent.OutputObject
    >;
    FheMin: TypedContractEvent<
      FheMinEvent.InputTuple,
      FheMinEvent.OutputTuple,
      FheMinEvent.OutputObject
    >;

    "FheMul(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheMulEvent.InputTuple,
      FheMulEvent.OutputTuple,
      FheMulEvent.OutputObject
    >;
    FheMul: TypedContractEvent<
      FheMulEvent.InputTuple,
      FheMulEvent.OutputTuple,
      FheMulEvent.OutputObject
    >;

    "FheNe(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheNeEvent.InputTuple,
      FheNeEvent.OutputTuple,
      FheNeEvent.OutputObject
    >;
    FheNe: TypedContractEvent<
      FheNeEvent.InputTuple,
      FheNeEvent.OutputTuple,
      FheNeEvent.OutputObject
    >;

    "FheNeg(address,bytes32,bytes32)": TypedContractEvent<
      FheNegEvent.InputTuple,
      FheNegEvent.OutputTuple,
      FheNegEvent.OutputObject
    >;
    FheNeg: TypedContractEvent<
      FheNegEvent.InputTuple,
      FheNegEvent.OutputTuple,
      FheNegEvent.OutputObject
    >;

    "FheNot(address,bytes32,bytes32)": TypedContractEvent<
      FheNotEvent.InputTuple,
      FheNotEvent.OutputTuple,
      FheNotEvent.OutputObject
    >;
    FheNot: TypedContractEvent<
      FheNotEvent.InputTuple,
      FheNotEvent.OutputTuple,
      FheNotEvent.OutputObject
    >;

    "FheRand(address,uint8,bytes16,bytes32)": TypedContractEvent<
      FheRandEvent.InputTuple,
      FheRandEvent.OutputTuple,
      FheRandEvent.OutputObject
    >;
    FheRand: TypedContractEvent<
      FheRandEvent.InputTuple,
      FheRandEvent.OutputTuple,
      FheRandEvent.OutputObject
    >;

    "FheRandBounded(address,uint256,uint8,bytes16,bytes32)": TypedContractEvent<
      FheRandBoundedEvent.InputTuple,
      FheRandBoundedEvent.OutputTuple,
      FheRandBoundedEvent.OutputObject
    >;
    FheRandBounded: TypedContractEvent<
      FheRandBoundedEvent.InputTuple,
      FheRandBoundedEvent.OutputTuple,
      FheRandBoundedEvent.OutputObject
    >;

    "FheRem(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheRemEvent.InputTuple,
      FheRemEvent.OutputTuple,
      FheRemEvent.OutputObject
    >;
    FheRem: TypedContractEvent<
      FheRemEvent.InputTuple,
      FheRemEvent.OutputTuple,
      FheRemEvent.OutputObject
    >;

    "FheRotl(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheRotlEvent.InputTuple,
      FheRotlEvent.OutputTuple,
      FheRotlEvent.OutputObject
    >;
    FheRotl: TypedContractEvent<
      FheRotlEvent.InputTuple,
      FheRotlEvent.OutputTuple,
      FheRotlEvent.OutputObject
    >;

    "FheRotr(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheRotrEvent.InputTuple,
      FheRotrEvent.OutputTuple,
      FheRotrEvent.OutputObject
    >;
    FheRotr: TypedContractEvent<
      FheRotrEvent.InputTuple,
      FheRotrEvent.OutputTuple,
      FheRotrEvent.OutputObject
    >;

    "FheShl(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheShlEvent.InputTuple,
      FheShlEvent.OutputTuple,
      FheShlEvent.OutputObject
    >;
    FheShl: TypedContractEvent<
      FheShlEvent.InputTuple,
      FheShlEvent.OutputTuple,
      FheShlEvent.OutputObject
    >;

    "FheShr(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheShrEvent.InputTuple,
      FheShrEvent.OutputTuple,
      FheShrEvent.OutputObject
    >;
    FheShr: TypedContractEvent<
      FheShrEvent.InputTuple,
      FheShrEvent.OutputTuple,
      FheShrEvent.OutputObject
    >;

    "FheSub(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheSubEvent.InputTuple,
      FheSubEvent.OutputTuple,
      FheSubEvent.OutputObject
    >;
    FheSub: TypedContractEvent<
      FheSubEvent.InputTuple,
      FheSubEvent.OutputTuple,
      FheSubEvent.OutputObject
    >;

    "Initialized(uint64)": TypedContractEvent<
      InitializedEvent.InputTuple,
      InitializedEvent.OutputTuple,
      InitializedEvent.OutputObject
    >;
    Initialized: TypedContractEvent<
      InitializedEvent.InputTuple,
      InitializedEvent.OutputTuple,
      InitializedEvent.OutputObject
    >;

    "OwnershipTransferStarted(address,address)": TypedContractEvent<
      OwnershipTransferStartedEvent.InputTuple,
      OwnershipTransferStartedEvent.OutputTuple,
      OwnershipTransferStartedEvent.OutputObject
    >;
    OwnershipTransferStarted: TypedContractEvent<
      OwnershipTransferStartedEvent.InputTuple,
      OwnershipTransferStartedEvent.OutputTuple,
      OwnershipTransferStartedEvent.OutputObject
    >;

    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;

    "TrivialEncrypt(address,uint256,uint8,bytes32)": TypedContractEvent<
      TrivialEncryptEvent.InputTuple,
      TrivialEncryptEvent.OutputTuple,
      TrivialEncryptEvent.OutputObject
    >;
    TrivialEncrypt: TypedContractEvent<
      TrivialEncryptEvent.InputTuple,
      TrivialEncryptEvent.OutputTuple,
      TrivialEncryptEvent.OutputObject
    >;

    "Upgraded(address)": TypedContractEvent<
      UpgradedEvent.InputTuple,
      UpgradedEvent.OutputTuple,
      UpgradedEvent.OutputObject
    >;
    Upgraded: TypedContractEvent<
      UpgradedEvent.InputTuple,
      UpgradedEvent.OutputTuple,
      UpgradedEvent.OutputObject
    >;

    "VerifyCiphertext(address,bytes32,address,bytes,uint8,bytes32)": TypedContractEvent<
      VerifyCiphertextEvent.InputTuple,
      VerifyCiphertextEvent.OutputTuple,
      VerifyCiphertextEvent.OutputObject
    >;
    VerifyCiphertext: TypedContractEvent<
      VerifyCiphertextEvent.InputTuple,
      VerifyCiphertextEvent.OutputTuple,
      VerifyCiphertextEvent.OutputObject
    >;
  };
}
