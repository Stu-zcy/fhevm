/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface FHEVMManualTestSuiteInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "eqEbool"
      | "eqEboolScalarL"
      | "eqEboolScalarR"
      | "neEbool"
      | "neEboolScalarL"
      | "neEboolScalarR"
      | "resAdd"
      | "resEbool"
      | "resEuint128"
      | "resEuint16"
      | "resEuint256"
      | "resEuint32"
      | "resEuint64"
      | "resEuint8"
      | "test_ebool_and"
      | "test_ebool_and_scalarL"
      | "test_ebool_and_scalarR"
      | "test_ebool_not"
      | "test_ebool_or"
      | "test_ebool_or_scalarL"
      | "test_ebool_or_scalarR"
      | "test_ebool_to_euint128_cast"
      | "test_ebool_to_euint16_cast"
      | "test_ebool_to_euint256_cast"
      | "test_ebool_to_euint32_cast"
      | "test_ebool_to_euint64_cast"
      | "test_ebool_to_euint8_cast"
      | "test_ebool_xor"
      | "test_ebool_xor_scalarL"
      | "test_ebool_xor_scalarR"
      | "test_eq_address_eaddress"
      | "test_eq_eaddress_address"
      | "test_eq_eaddress_eaddress"
      | "test_euint128_to_euint8_cast"
      | "test_ne_address_eaddress"
      | "test_ne_eaddress_address"
      | "test_ne_eaddress_eaddress"
      | "test_select"
      | "test_select_eaddress"
      | "test_select_ebool"
  ): FunctionFragment;

  getEvent(nameOrSignatureOrTopic: "DebugVerify"): EventFragment;

  encodeFunctionData(
    functionFragment: "eqEbool",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "eqEboolScalarL",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "eqEboolScalarR",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "neEbool",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "neEboolScalarL",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "neEboolScalarR",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(functionFragment: "resAdd", values?: undefined): string;
  encodeFunctionData(functionFragment: "resEbool", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "resEuint128",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "resEuint16",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "resEuint256",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "resEuint32",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "resEuint64",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "resEuint8", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "test_ebool_and",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ebool_and_scalarL",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ebool_and_scalarR",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ebool_not",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ebool_or",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ebool_or_scalarL",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ebool_or_scalarR",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ebool_to_euint128_cast",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ebool_to_euint16_cast",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ebool_to_euint256_cast",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ebool_to_euint32_cast",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ebool_to_euint64_cast",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ebool_to_euint8_cast",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ebool_xor",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ebool_xor_scalarL",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ebool_xor_scalarR",
    values: [boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "test_eq_address_eaddress",
    values: [BytesLike, AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "test_eq_eaddress_address",
    values: [BytesLike, AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "test_eq_eaddress_eaddress",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "test_euint128_to_euint8_cast",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ne_address_eaddress",
    values: [BytesLike, AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ne_eaddress_address",
    values: [BytesLike, AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "test_ne_eaddress_eaddress",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "test_select",
    values: [BytesLike, BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "test_select_eaddress",
    values: [BytesLike, BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "test_select_ebool",
    values: [boolean, boolean, boolean]
  ): string;

  decodeFunctionResult(functionFragment: "eqEbool", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "eqEboolScalarL",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "eqEboolScalarR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "neEbool", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "neEboolScalarL",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "neEboolScalarR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "resAdd", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "resEbool", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "resEuint128",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "resEuint16", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "resEuint256",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "resEuint32", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "resEuint64", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "resEuint8", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_and",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_and_scalarL",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_and_scalarR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_not",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_or",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_or_scalarL",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_or_scalarR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_to_euint128_cast",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_to_euint16_cast",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_to_euint256_cast",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_to_euint32_cast",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_to_euint64_cast",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_to_euint8_cast",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_xor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_xor_scalarL",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ebool_xor_scalarR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_eq_address_eaddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_eq_eaddress_address",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_eq_eaddress_eaddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_euint128_to_euint8_cast",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ne_address_eaddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ne_eaddress_address",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_ne_eaddress_eaddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_select",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_select_eaddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "test_select_ebool",
    data: BytesLike
  ): Result;
}

export namespace DebugVerifyEvent {
  export type InputTuple = [
    inputHandle: BytesLike,
    inputProof: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    inputHandle: string,
    inputProof: string,
    result: string
  ];
  export interface OutputObject {
    inputHandle: string;
    inputProof: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface FHEVMManualTestSuite extends BaseContract {
  connect(runner?: ContractRunner | null): FHEVMManualTestSuite;
  waitForDeployment(): Promise<this>;

  interface: FHEVMManualTestSuiteInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  eqEbool: TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;

  eqEboolScalarL: TypedContractMethod<
    [a: boolean, b: boolean],
    [void],
    "nonpayable"
  >;

  eqEboolScalarR: TypedContractMethod<
    [a: boolean, b: boolean],
    [void],
    "nonpayable"
  >;

  neEbool: TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;

  neEboolScalarL: TypedContractMethod<
    [a: boolean, b: boolean],
    [void],
    "nonpayable"
  >;

  neEboolScalarR: TypedContractMethod<
    [a: boolean, b: boolean],
    [void],
    "nonpayable"
  >;

  resAdd: TypedContractMethod<[], [string], "view">;

  resEbool: TypedContractMethod<[], [string], "view">;

  resEuint128: TypedContractMethod<[], [string], "view">;

  resEuint16: TypedContractMethod<[], [string], "view">;

  resEuint256: TypedContractMethod<[], [string], "view">;

  resEuint32: TypedContractMethod<[], [string], "view">;

  resEuint64: TypedContractMethod<[], [string], "view">;

  resEuint8: TypedContractMethod<[], [string], "view">;

  test_ebool_and: TypedContractMethod<
    [a: boolean, b: boolean],
    [void],
    "nonpayable"
  >;

  test_ebool_and_scalarL: TypedContractMethod<
    [a: boolean, b: boolean],
    [void],
    "nonpayable"
  >;

  test_ebool_and_scalarR: TypedContractMethod<
    [a: boolean, b: boolean],
    [void],
    "nonpayable"
  >;

  test_ebool_not: TypedContractMethod<[input: boolean], [void], "nonpayable">;

  test_ebool_or: TypedContractMethod<
    [a: boolean, b: boolean],
    [void],
    "nonpayable"
  >;

  test_ebool_or_scalarL: TypedContractMethod<
    [a: boolean, b: boolean],
    [void],
    "nonpayable"
  >;

  test_ebool_or_scalarR: TypedContractMethod<
    [a: boolean, b: boolean],
    [void],
    "nonpayable"
  >;

  test_ebool_to_euint128_cast: TypedContractMethod<
    [input: boolean],
    [void],
    "nonpayable"
  >;

  test_ebool_to_euint16_cast: TypedContractMethod<
    [input: boolean],
    [void],
    "nonpayable"
  >;

  test_ebool_to_euint256_cast: TypedContractMethod<
    [input: boolean],
    [void],
    "nonpayable"
  >;

  test_ebool_to_euint32_cast: TypedContractMethod<
    [input: boolean],
    [void],
    "nonpayable"
  >;

  test_ebool_to_euint64_cast: TypedContractMethod<
    [input: boolean],
    [void],
    "nonpayable"
  >;

  test_ebool_to_euint8_cast: TypedContractMethod<
    [input: boolean],
    [void],
    "nonpayable"
  >;

  test_ebool_xor: TypedContractMethod<
    [a: boolean, b: boolean],
    [void],
    "nonpayable"
  >;

  test_ebool_xor_scalarL: TypedContractMethod<
    [a: boolean, b: boolean],
    [void],
    "nonpayable"
  >;

  test_ebool_xor_scalarR: TypedContractMethod<
    [a: boolean, b: boolean],
    [void],
    "nonpayable"
  >;

  test_eq_address_eaddress: TypedContractMethod<
    [a: BytesLike, b: AddressLike, inputProof: BytesLike],
    [void],
    "nonpayable"
  >;

  test_eq_eaddress_address: TypedContractMethod<
    [a: BytesLike, b: AddressLike, inputProof: BytesLike],
    [void],
    "nonpayable"
  >;

  test_eq_eaddress_eaddress: TypedContractMethod<
    [a: BytesLike, b: BytesLike, inputProof: BytesLike],
    [void],
    "nonpayable"
  >;

  test_euint128_to_euint8_cast: TypedContractMethod<
    [input: BigNumberish],
    [void],
    "nonpayable"
  >;

  test_ne_address_eaddress: TypedContractMethod<
    [a: BytesLike, b: AddressLike, inputProof: BytesLike],
    [void],
    "nonpayable"
  >;

  test_ne_eaddress_address: TypedContractMethod<
    [a: BytesLike, b: AddressLike, inputProof: BytesLike],
    [void],
    "nonpayable"
  >;

  test_ne_eaddress_eaddress: TypedContractMethod<
    [a: BytesLike, b: BytesLike, inputProof: BytesLike],
    [void],
    "nonpayable"
  >;

  test_select: TypedContractMethod<
    [
      control: BytesLike,
      ifTrue: BytesLike,
      ifFalse: BytesLike,
      inputProof: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  test_select_eaddress: TypedContractMethod<
    [
      control: BytesLike,
      ifTrue: BytesLike,
      ifFalse: BytesLike,
      inputProof: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  test_select_ebool: TypedContractMethod<
    [control: boolean, ifTrue: boolean, ifFalse: boolean],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "eqEbool"
  ): TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "eqEboolScalarL"
  ): TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "eqEboolScalarR"
  ): TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "neEbool"
  ): TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "neEboolScalarL"
  ): TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "neEboolScalarR"
  ): TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "resAdd"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "resEbool"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "resEuint128"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "resEuint16"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "resEuint256"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "resEuint32"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "resEuint64"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "resEuint8"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "test_ebool_and"
  ): TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ebool_and_scalarL"
  ): TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ebool_and_scalarR"
  ): TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ebool_not"
  ): TypedContractMethod<[input: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ebool_or"
  ): TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ebool_or_scalarL"
  ): TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ebool_or_scalarR"
  ): TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ebool_to_euint128_cast"
  ): TypedContractMethod<[input: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ebool_to_euint16_cast"
  ): TypedContractMethod<[input: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ebool_to_euint256_cast"
  ): TypedContractMethod<[input: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ebool_to_euint32_cast"
  ): TypedContractMethod<[input: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ebool_to_euint64_cast"
  ): TypedContractMethod<[input: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ebool_to_euint8_cast"
  ): TypedContractMethod<[input: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ebool_xor"
  ): TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ebool_xor_scalarL"
  ): TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ebool_xor_scalarR"
  ): TypedContractMethod<[a: boolean, b: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_eq_address_eaddress"
  ): TypedContractMethod<
    [a: BytesLike, b: AddressLike, inputProof: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "test_eq_eaddress_address"
  ): TypedContractMethod<
    [a: BytesLike, b: AddressLike, inputProof: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "test_eq_eaddress_eaddress"
  ): TypedContractMethod<
    [a: BytesLike, b: BytesLike, inputProof: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "test_euint128_to_euint8_cast"
  ): TypedContractMethod<[input: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "test_ne_address_eaddress"
  ): TypedContractMethod<
    [a: BytesLike, b: AddressLike, inputProof: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "test_ne_eaddress_address"
  ): TypedContractMethod<
    [a: BytesLike, b: AddressLike, inputProof: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "test_ne_eaddress_eaddress"
  ): TypedContractMethod<
    [a: BytesLike, b: BytesLike, inputProof: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "test_select"
  ): TypedContractMethod<
    [
      control: BytesLike,
      ifTrue: BytesLike,
      ifFalse: BytesLike,
      inputProof: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "test_select_eaddress"
  ): TypedContractMethod<
    [
      control: BytesLike,
      ifTrue: BytesLike,
      ifFalse: BytesLike,
      inputProof: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "test_select_ebool"
  ): TypedContractMethod<
    [control: boolean, ifTrue: boolean, ifFalse: boolean],
    [void],
    "nonpayable"
  >;

  getEvent(
    key: "DebugVerify"
  ): TypedContractEvent<
    DebugVerifyEvent.InputTuple,
    DebugVerifyEvent.OutputTuple,
    DebugVerifyEvent.OutputObject
  >;

  filters: {
    "DebugVerify(bytes32,bytes,bytes32)": TypedContractEvent<
      DebugVerifyEvent.InputTuple,
      DebugVerifyEvent.OutputTuple,
      DebugVerifyEvent.OutputObject
    >;
    DebugVerify: TypedContractEvent<
      DebugVerifyEvent.InputTuple,
      DebugVerifyEvent.OutputTuple,
      DebugVerifyEvent.OutputObject
    >;
  };
}
