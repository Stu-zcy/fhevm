/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
} from "../common";

export interface FHEEventsInterface extends Interface {
  getEvent(
    nameOrSignatureOrTopic:
      | "Cast"
      | "FheAdd"
      | "FheBitAnd"
      | "FheBitOr"
      | "FheBitXor"
      | "FheDiv"
      | "FheEq"
      | "FheGe"
      | "FheGt"
      | "FheIfThenElse"
      | "FheLe"
      | "FheLt"
      | "FheMax"
      | "FheMin"
      | "FheMul"
      | "FheNe"
      | "FheNeg"
      | "FheNot"
      | "FheRand"
      | "FheRandBounded"
      | "FheRem"
      | "FheRotl"
      | "FheRotr"
      | "FheShl"
      | "FheShr"
      | "FheSub"
      | "TrivialEncrypt"
      | "VerifyCiphertext"
  ): EventFragment;
}

export namespace CastEvent {
  export type InputTuple = [
    caller: AddressLike,
    ct: BytesLike,
    toType: BigNumberish,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    ct: string,
    toType: bigint,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    ct: string;
    toType: bigint;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheAddEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheBitAndEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheBitOrEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheBitXorEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheDivEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheEqEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheGeEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheGtEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheIfThenElseEvent {
  export type InputTuple = [
    caller: AddressLike,
    control: BytesLike,
    ifTrue: BytesLike,
    ifFalse: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    control: string,
    ifTrue: string,
    ifFalse: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    control: string;
    ifTrue: string;
    ifFalse: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheLeEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheLtEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheMaxEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheMinEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheMulEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheNeEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheNegEvent {
  export type InputTuple = [
    caller: AddressLike,
    ct: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [caller: string, ct: string, result: string];
  export interface OutputObject {
    caller: string;
    ct: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheNotEvent {
  export type InputTuple = [
    caller: AddressLike,
    ct: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [caller: string, ct: string, result: string];
  export interface OutputObject {
    caller: string;
    ct: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheRandEvent {
  export type InputTuple = [
    caller: AddressLike,
    randType: BigNumberish,
    seed: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    randType: bigint,
    seed: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    randType: bigint;
    seed: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheRandBoundedEvent {
  export type InputTuple = [
    caller: AddressLike,
    upperBound: BigNumberish,
    randType: BigNumberish,
    seed: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    upperBound: bigint,
    randType: bigint,
    seed: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    upperBound: bigint;
    randType: bigint;
    seed: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheRemEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheRotlEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheRotrEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheShlEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheShrEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheSubEvent {
  export type InputTuple = [
    caller: AddressLike,
    lhs: BytesLike,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    lhs: string,
    rhs: string,
    scalarByte: string,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    lhs: string;
    rhs: string;
    scalarByte: string;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TrivialEncryptEvent {
  export type InputTuple = [
    caller: AddressLike,
    pt: BigNumberish,
    toType: BigNumberish,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    pt: bigint,
    toType: bigint,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    pt: bigint;
    toType: bigint;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace VerifyCiphertextEvent {
  export type InputTuple = [
    caller: AddressLike,
    inputHandle: BytesLike,
    userAddress: AddressLike,
    inputProof: BytesLike,
    inputType: BigNumberish,
    result: BytesLike
  ];
  export type OutputTuple = [
    caller: string,
    inputHandle: string,
    userAddress: string,
    inputProof: string,
    inputType: bigint,
    result: string
  ];
  export interface OutputObject {
    caller: string;
    inputHandle: string;
    userAddress: string;
    inputProof: string;
    inputType: bigint;
    result: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface FHEEvents extends BaseContract {
  connect(runner?: ContractRunner | null): FHEEvents;
  waitForDeployment(): Promise<this>;

  interface: FHEEventsInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getEvent(
    key: "Cast"
  ): TypedContractEvent<
    CastEvent.InputTuple,
    CastEvent.OutputTuple,
    CastEvent.OutputObject
  >;
  getEvent(
    key: "FheAdd"
  ): TypedContractEvent<
    FheAddEvent.InputTuple,
    FheAddEvent.OutputTuple,
    FheAddEvent.OutputObject
  >;
  getEvent(
    key: "FheBitAnd"
  ): TypedContractEvent<
    FheBitAndEvent.InputTuple,
    FheBitAndEvent.OutputTuple,
    FheBitAndEvent.OutputObject
  >;
  getEvent(
    key: "FheBitOr"
  ): TypedContractEvent<
    FheBitOrEvent.InputTuple,
    FheBitOrEvent.OutputTuple,
    FheBitOrEvent.OutputObject
  >;
  getEvent(
    key: "FheBitXor"
  ): TypedContractEvent<
    FheBitXorEvent.InputTuple,
    FheBitXorEvent.OutputTuple,
    FheBitXorEvent.OutputObject
  >;
  getEvent(
    key: "FheDiv"
  ): TypedContractEvent<
    FheDivEvent.InputTuple,
    FheDivEvent.OutputTuple,
    FheDivEvent.OutputObject
  >;
  getEvent(
    key: "FheEq"
  ): TypedContractEvent<
    FheEqEvent.InputTuple,
    FheEqEvent.OutputTuple,
    FheEqEvent.OutputObject
  >;
  getEvent(
    key: "FheGe"
  ): TypedContractEvent<
    FheGeEvent.InputTuple,
    FheGeEvent.OutputTuple,
    FheGeEvent.OutputObject
  >;
  getEvent(
    key: "FheGt"
  ): TypedContractEvent<
    FheGtEvent.InputTuple,
    FheGtEvent.OutputTuple,
    FheGtEvent.OutputObject
  >;
  getEvent(
    key: "FheIfThenElse"
  ): TypedContractEvent<
    FheIfThenElseEvent.InputTuple,
    FheIfThenElseEvent.OutputTuple,
    FheIfThenElseEvent.OutputObject
  >;
  getEvent(
    key: "FheLe"
  ): TypedContractEvent<
    FheLeEvent.InputTuple,
    FheLeEvent.OutputTuple,
    FheLeEvent.OutputObject
  >;
  getEvent(
    key: "FheLt"
  ): TypedContractEvent<
    FheLtEvent.InputTuple,
    FheLtEvent.OutputTuple,
    FheLtEvent.OutputObject
  >;
  getEvent(
    key: "FheMax"
  ): TypedContractEvent<
    FheMaxEvent.InputTuple,
    FheMaxEvent.OutputTuple,
    FheMaxEvent.OutputObject
  >;
  getEvent(
    key: "FheMin"
  ): TypedContractEvent<
    FheMinEvent.InputTuple,
    FheMinEvent.OutputTuple,
    FheMinEvent.OutputObject
  >;
  getEvent(
    key: "FheMul"
  ): TypedContractEvent<
    FheMulEvent.InputTuple,
    FheMulEvent.OutputTuple,
    FheMulEvent.OutputObject
  >;
  getEvent(
    key: "FheNe"
  ): TypedContractEvent<
    FheNeEvent.InputTuple,
    FheNeEvent.OutputTuple,
    FheNeEvent.OutputObject
  >;
  getEvent(
    key: "FheNeg"
  ): TypedContractEvent<
    FheNegEvent.InputTuple,
    FheNegEvent.OutputTuple,
    FheNegEvent.OutputObject
  >;
  getEvent(
    key: "FheNot"
  ): TypedContractEvent<
    FheNotEvent.InputTuple,
    FheNotEvent.OutputTuple,
    FheNotEvent.OutputObject
  >;
  getEvent(
    key: "FheRand"
  ): TypedContractEvent<
    FheRandEvent.InputTuple,
    FheRandEvent.OutputTuple,
    FheRandEvent.OutputObject
  >;
  getEvent(
    key: "FheRandBounded"
  ): TypedContractEvent<
    FheRandBoundedEvent.InputTuple,
    FheRandBoundedEvent.OutputTuple,
    FheRandBoundedEvent.OutputObject
  >;
  getEvent(
    key: "FheRem"
  ): TypedContractEvent<
    FheRemEvent.InputTuple,
    FheRemEvent.OutputTuple,
    FheRemEvent.OutputObject
  >;
  getEvent(
    key: "FheRotl"
  ): TypedContractEvent<
    FheRotlEvent.InputTuple,
    FheRotlEvent.OutputTuple,
    FheRotlEvent.OutputObject
  >;
  getEvent(
    key: "FheRotr"
  ): TypedContractEvent<
    FheRotrEvent.InputTuple,
    FheRotrEvent.OutputTuple,
    FheRotrEvent.OutputObject
  >;
  getEvent(
    key: "FheShl"
  ): TypedContractEvent<
    FheShlEvent.InputTuple,
    FheShlEvent.OutputTuple,
    FheShlEvent.OutputObject
  >;
  getEvent(
    key: "FheShr"
  ): TypedContractEvent<
    FheShrEvent.InputTuple,
    FheShrEvent.OutputTuple,
    FheShrEvent.OutputObject
  >;
  getEvent(
    key: "FheSub"
  ): TypedContractEvent<
    FheSubEvent.InputTuple,
    FheSubEvent.OutputTuple,
    FheSubEvent.OutputObject
  >;
  getEvent(
    key: "TrivialEncrypt"
  ): TypedContractEvent<
    TrivialEncryptEvent.InputTuple,
    TrivialEncryptEvent.OutputTuple,
    TrivialEncryptEvent.OutputObject
  >;
  getEvent(
    key: "VerifyCiphertext"
  ): TypedContractEvent<
    VerifyCiphertextEvent.InputTuple,
    VerifyCiphertextEvent.OutputTuple,
    VerifyCiphertextEvent.OutputObject
  >;

  filters: {
    "Cast(address,bytes32,uint8,bytes32)": TypedContractEvent<
      CastEvent.InputTuple,
      CastEvent.OutputTuple,
      CastEvent.OutputObject
    >;
    Cast: TypedContractEvent<
      CastEvent.InputTuple,
      CastEvent.OutputTuple,
      CastEvent.OutputObject
    >;

    "FheAdd(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheAddEvent.InputTuple,
      FheAddEvent.OutputTuple,
      FheAddEvent.OutputObject
    >;
    FheAdd: TypedContractEvent<
      FheAddEvent.InputTuple,
      FheAddEvent.OutputTuple,
      FheAddEvent.OutputObject
    >;

    "FheBitAnd(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheBitAndEvent.InputTuple,
      FheBitAndEvent.OutputTuple,
      FheBitAndEvent.OutputObject
    >;
    FheBitAnd: TypedContractEvent<
      FheBitAndEvent.InputTuple,
      FheBitAndEvent.OutputTuple,
      FheBitAndEvent.OutputObject
    >;

    "FheBitOr(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheBitOrEvent.InputTuple,
      FheBitOrEvent.OutputTuple,
      FheBitOrEvent.OutputObject
    >;
    FheBitOr: TypedContractEvent<
      FheBitOrEvent.InputTuple,
      FheBitOrEvent.OutputTuple,
      FheBitOrEvent.OutputObject
    >;

    "FheBitXor(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheBitXorEvent.InputTuple,
      FheBitXorEvent.OutputTuple,
      FheBitXorEvent.OutputObject
    >;
    FheBitXor: TypedContractEvent<
      FheBitXorEvent.InputTuple,
      FheBitXorEvent.OutputTuple,
      FheBitXorEvent.OutputObject
    >;

    "FheDiv(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheDivEvent.InputTuple,
      FheDivEvent.OutputTuple,
      FheDivEvent.OutputObject
    >;
    FheDiv: TypedContractEvent<
      FheDivEvent.InputTuple,
      FheDivEvent.OutputTuple,
      FheDivEvent.OutputObject
    >;

    "FheEq(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheEqEvent.InputTuple,
      FheEqEvent.OutputTuple,
      FheEqEvent.OutputObject
    >;
    FheEq: TypedContractEvent<
      FheEqEvent.InputTuple,
      FheEqEvent.OutputTuple,
      FheEqEvent.OutputObject
    >;

    "FheGe(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheGeEvent.InputTuple,
      FheGeEvent.OutputTuple,
      FheGeEvent.OutputObject
    >;
    FheGe: TypedContractEvent<
      FheGeEvent.InputTuple,
      FheGeEvent.OutputTuple,
      FheGeEvent.OutputObject
    >;

    "FheGt(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheGtEvent.InputTuple,
      FheGtEvent.OutputTuple,
      FheGtEvent.OutputObject
    >;
    FheGt: TypedContractEvent<
      FheGtEvent.InputTuple,
      FheGtEvent.OutputTuple,
      FheGtEvent.OutputObject
    >;

    "FheIfThenElse(address,bytes32,bytes32,bytes32,bytes32)": TypedContractEvent<
      FheIfThenElseEvent.InputTuple,
      FheIfThenElseEvent.OutputTuple,
      FheIfThenElseEvent.OutputObject
    >;
    FheIfThenElse: TypedContractEvent<
      FheIfThenElseEvent.InputTuple,
      FheIfThenElseEvent.OutputTuple,
      FheIfThenElseEvent.OutputObject
    >;

    "FheLe(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheLeEvent.InputTuple,
      FheLeEvent.OutputTuple,
      FheLeEvent.OutputObject
    >;
    FheLe: TypedContractEvent<
      FheLeEvent.InputTuple,
      FheLeEvent.OutputTuple,
      FheLeEvent.OutputObject
    >;

    "FheLt(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheLtEvent.InputTuple,
      FheLtEvent.OutputTuple,
      FheLtEvent.OutputObject
    >;
    FheLt: TypedContractEvent<
      FheLtEvent.InputTuple,
      FheLtEvent.OutputTuple,
      FheLtEvent.OutputObject
    >;

    "FheMax(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheMaxEvent.InputTuple,
      FheMaxEvent.OutputTuple,
      FheMaxEvent.OutputObject
    >;
    FheMax: TypedContractEvent<
      FheMaxEvent.InputTuple,
      FheMaxEvent.OutputTuple,
      FheMaxEvent.OutputObject
    >;

    "FheMin(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheMinEvent.InputTuple,
      FheMinEvent.OutputTuple,
      FheMinEvent.OutputObject
    >;
    FheMin: TypedContractEvent<
      FheMinEvent.InputTuple,
      FheMinEvent.OutputTuple,
      FheMinEvent.OutputObject
    >;

    "FheMul(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheMulEvent.InputTuple,
      FheMulEvent.OutputTuple,
      FheMulEvent.OutputObject
    >;
    FheMul: TypedContractEvent<
      FheMulEvent.InputTuple,
      FheMulEvent.OutputTuple,
      FheMulEvent.OutputObject
    >;

    "FheNe(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheNeEvent.InputTuple,
      FheNeEvent.OutputTuple,
      FheNeEvent.OutputObject
    >;
    FheNe: TypedContractEvent<
      FheNeEvent.InputTuple,
      FheNeEvent.OutputTuple,
      FheNeEvent.OutputObject
    >;

    "FheNeg(address,bytes32,bytes32)": TypedContractEvent<
      FheNegEvent.InputTuple,
      FheNegEvent.OutputTuple,
      FheNegEvent.OutputObject
    >;
    FheNeg: TypedContractEvent<
      FheNegEvent.InputTuple,
      FheNegEvent.OutputTuple,
      FheNegEvent.OutputObject
    >;

    "FheNot(address,bytes32,bytes32)": TypedContractEvent<
      FheNotEvent.InputTuple,
      FheNotEvent.OutputTuple,
      FheNotEvent.OutputObject
    >;
    FheNot: TypedContractEvent<
      FheNotEvent.InputTuple,
      FheNotEvent.OutputTuple,
      FheNotEvent.OutputObject
    >;

    "FheRand(address,uint8,bytes16,bytes32)": TypedContractEvent<
      FheRandEvent.InputTuple,
      FheRandEvent.OutputTuple,
      FheRandEvent.OutputObject
    >;
    FheRand: TypedContractEvent<
      FheRandEvent.InputTuple,
      FheRandEvent.OutputTuple,
      FheRandEvent.OutputObject
    >;

    "FheRandBounded(address,uint256,uint8,bytes16,bytes32)": TypedContractEvent<
      FheRandBoundedEvent.InputTuple,
      FheRandBoundedEvent.OutputTuple,
      FheRandBoundedEvent.OutputObject
    >;
    FheRandBounded: TypedContractEvent<
      FheRandBoundedEvent.InputTuple,
      FheRandBoundedEvent.OutputTuple,
      FheRandBoundedEvent.OutputObject
    >;

    "FheRem(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheRemEvent.InputTuple,
      FheRemEvent.OutputTuple,
      FheRemEvent.OutputObject
    >;
    FheRem: TypedContractEvent<
      FheRemEvent.InputTuple,
      FheRemEvent.OutputTuple,
      FheRemEvent.OutputObject
    >;

    "FheRotl(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheRotlEvent.InputTuple,
      FheRotlEvent.OutputTuple,
      FheRotlEvent.OutputObject
    >;
    FheRotl: TypedContractEvent<
      FheRotlEvent.InputTuple,
      FheRotlEvent.OutputTuple,
      FheRotlEvent.OutputObject
    >;

    "FheRotr(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheRotrEvent.InputTuple,
      FheRotrEvent.OutputTuple,
      FheRotrEvent.OutputObject
    >;
    FheRotr: TypedContractEvent<
      FheRotrEvent.InputTuple,
      FheRotrEvent.OutputTuple,
      FheRotrEvent.OutputObject
    >;

    "FheShl(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheShlEvent.InputTuple,
      FheShlEvent.OutputTuple,
      FheShlEvent.OutputObject
    >;
    FheShl: TypedContractEvent<
      FheShlEvent.InputTuple,
      FheShlEvent.OutputTuple,
      FheShlEvent.OutputObject
    >;

    "FheShr(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheShrEvent.InputTuple,
      FheShrEvent.OutputTuple,
      FheShrEvent.OutputObject
    >;
    FheShr: TypedContractEvent<
      FheShrEvent.InputTuple,
      FheShrEvent.OutputTuple,
      FheShrEvent.OutputObject
    >;

    "FheSub(address,bytes32,bytes32,bytes1,bytes32)": TypedContractEvent<
      FheSubEvent.InputTuple,
      FheSubEvent.OutputTuple,
      FheSubEvent.OutputObject
    >;
    FheSub: TypedContractEvent<
      FheSubEvent.InputTuple,
      FheSubEvent.OutputTuple,
      FheSubEvent.OutputObject
    >;

    "TrivialEncrypt(address,uint256,uint8,bytes32)": TypedContractEvent<
      TrivialEncryptEvent.InputTuple,
      TrivialEncryptEvent.OutputTuple,
      TrivialEncryptEvent.OutputObject
    >;
    TrivialEncrypt: TypedContractEvent<
      TrivialEncryptEvent.InputTuple,
      TrivialEncryptEvent.OutputTuple,
      TrivialEncryptEvent.OutputObject
    >;

    "VerifyCiphertext(address,bytes32,address,bytes,uint8,bytes32)": TypedContractEvent<
      VerifyCiphertextEvent.InputTuple,
      VerifyCiphertextEvent.OutputTuple,
      VerifyCiphertextEvent.OutputObject
    >;
    VerifyCiphertext: TypedContractEvent<
      VerifyCiphertextEvent.InputTuple,
      VerifyCiphertextEvent.OutputTuple,
      VerifyCiphertextEvent.OutputObject
    >;
  };
}
